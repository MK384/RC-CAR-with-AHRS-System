/*
 * MPU6050_DMP.c
 *
 *  	Created on: Jul 19, 2023
 *      Author: Mohammed Khaled <Mohammed.Kh384@gmail.com>
 *
 * This file contains the function implementation of the Digital Motion Processing (DMP) functionality for the MPU6050 sensor using the I2Cdev library.
 * The DMP is a utility function that assists in motion and orientation tracking by offloading some processing from the host Microcontroller.
 * As before, the original library by "Jeff Rowberg" was adapted for STM32 and rewritten in C for reduced memory usage.
 * The purpose of this file is to handle the DMP functionality provided by the MPU6050 sensor. It includes functions such as:
 * By separating the DMP-related code into its own file, it improves code organization and allows for easier maintenance and modification
 * of this specific functionality.
 *
 * The original code in I2Cdev library was partially refactored and grouped in Three files:
 *
 * (1) MPU6050_Basic (.h /.c) :
 * 		contains the implementation of basic sensor operations for the MPU6050 IMU ,
 * 		It provides functions for configuring the sensor and retrieving raw data from it.
 *
 *
 * (2) MPU6050_Advanced (.h /.c) :
 * 		contains the implementation of more advanced features for the MPU6050 sensor using the I2Cdev library.
 * 		It includes functions for dealing with slave external sensors and MPU I2C master operations.
 *
 * 	(3) MPU6050_DMP (.h /.c) :
 * 		 contains the implementation of the Digital Motion Processing (DMP) functionality for the MPU6050 sensor using the I2Cdev library.
 *
 *  In Addition to the dependency file I2cdev based on STM32 HAL Library.
 *
 */


/* Includes ------------------------------------------------------------------*/
#include	"MPU6050_DMP.h"
#include	"math.h"
#include 	<string.h>




/* Private needed defines ------------------------------------------------------------------*/
static uint8_t devAddr	   =		MPU6050_I2C_ADDR_AD0_LOW;
/* Private Variables ------------------------------------------------------------------*/

static uint16_t dmpPacketSize = 0;


// this block of memory gets written to the MPU on start-up, and it seems
// to be volatile memory, so it has to be done each time (it only takes ~1
// second though)

static const unsigned char dmpMemory[MPU6050_DMP_CODE_SIZE] = {
    // bank 0, 256 bytes
    0xFB, 0x00, 0x00, 0x3E, 0x00, 0x0B, 0x00, 0x36, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0x00, 0x00,
    0x00, 0x65, 0x00, 0x54, 0xFF, 0xEF, 0x00, 0x00, 0xFA, 0x80, 0x00, 0x0B, 0x12, 0x82, 0x00, 0x01,
    0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x28, 0x00, 0x00, 0xFF, 0xFF, 0x45, 0x81, 0xFF, 0xFF, 0xFA, 0x72, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x03, 0xE8, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x7F, 0xFF, 0xFF, 0xFE, 0x80, 0x01,
    0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x3E, 0x03, 0x30, 0x40, 0x00, 0x00, 0x00, 0x02, 0xCA, 0xE3, 0x09, 0x3E, 0x80, 0x00, 0x00,
    0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
    0x41, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x2A, 0x00, 0x00, 0x16, 0x55, 0x00, 0x00, 0x21, 0x82,
    0xFD, 0x87, 0x26, 0x50, 0xFD, 0x80, 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x05, 0x80, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x6F, 0x00, 0x02, 0x65, 0x32, 0x00, 0x00, 0x5E, 0xC0,
    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFB, 0x8C, 0x6F, 0x5D, 0xFD, 0x5D, 0x08, 0xD9, 0x00, 0x7C, 0x73, 0x3B, 0x00, 0x6C, 0x12, 0xCC,
    0x32, 0x00, 0x13, 0x9D, 0x32, 0x00, 0xD0, 0xD6, 0x32, 0x00, 0x08, 0x00, 0x40, 0x00, 0x01, 0xF4,
    0xFF, 0xE6, 0x80, 0x79, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0, 0xD6, 0x00, 0x00, 0x27, 0x10,

    // bank 1, 256 bytes
    0xFB, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFA, 0x36, 0xFF, 0xBC, 0x30, 0x8E, 0x00, 0x05, 0xFB, 0xF0, 0xFF, 0xD9, 0x5B, 0xC8,
    0xFF, 0xD0, 0x9A, 0xBE, 0x00, 0x00, 0x10, 0xA9, 0xFF, 0xF4, 0x1E, 0xB2, 0x00, 0xCE, 0xBB, 0xF7,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x02, 0x00, 0x02, 0x02, 0x00, 0x00, 0x0C,
    0xFF, 0xC2, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0xCF, 0x80, 0x00, 0x40, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x14,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x03, 0x3F, 0x68, 0xB6, 0x79, 0x35, 0x28, 0xBC, 0xC6, 0x7E, 0xD1, 0x6C,
    0x80, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB2, 0x6A, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xF0, 0x00, 0x00, 0x00, 0x30,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x25, 0x4D, 0x00, 0x2F, 0x70, 0x6D, 0x00, 0x00, 0x05, 0xAE, 0x00, 0x0C, 0x02, 0xD0,

    // bank 2, 256 bytes
    0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x54, 0xFF, 0xEF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x01, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0xFF, 0xEF, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
    0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    // bank 3, 256 bytes
    0xD8, 0xDC, 0xBA, 0xA2, 0xF1, 0xDE, 0xB2, 0xB8, 0xB4, 0xA8, 0x81, 0x91, 0xF7, 0x4A, 0x90, 0x7F,
    0x91, 0x6A, 0xF3, 0xF9, 0xDB, 0xA8, 0xF9, 0xB0, 0xBA, 0xA0, 0x80, 0xF2, 0xCE, 0x81, 0xF3, 0xC2,
    0xF1, 0xC1, 0xF2, 0xC3, 0xF3, 0xCC, 0xA2, 0xB2, 0x80, 0xF1, 0xC6, 0xD8, 0x80, 0xBA, 0xA7, 0xDF,
    0xDF, 0xDF, 0xF2, 0xA7, 0xC3, 0xCB, 0xC5, 0xB6, 0xF0, 0x87, 0xA2, 0x94, 0x24, 0x48, 0x70, 0x3C,
    0x95, 0x40, 0x68, 0x34, 0x58, 0x9B, 0x78, 0xA2, 0xF1, 0x83, 0x92, 0x2D, 0x55, 0x7D, 0xD8, 0xB1,
    0xB4, 0xB8, 0xA1, 0xD0, 0x91, 0x80, 0xF2, 0x70, 0xF3, 0x70, 0xF2, 0x7C, 0x80, 0xA8, 0xF1, 0x01,
    0xB0, 0x98, 0x87, 0xD9, 0x43, 0xD8, 0x86, 0xC9, 0x88, 0xBA, 0xA1, 0xF2, 0x0E, 0xB8, 0x97, 0x80,
    0xF1, 0xA9, 0xDF, 0xDF, 0xDF, 0xAA, 0xDF, 0xDF, 0xDF, 0xF2, 0xAA, 0xC5, 0xCD, 0xC7, 0xA9, 0x0C,
    0xC9, 0x2C, 0x97, 0x97, 0x97, 0x97, 0xF1, 0xA9, 0x89, 0x26, 0x46, 0x66, 0xB0, 0xB4, 0xBA, 0x80,
    0xAC, 0xDE, 0xF2, 0xCA, 0xF1, 0xB2, 0x8C, 0x02, 0xA9, 0xB6, 0x98, 0x00, 0x89, 0x0E, 0x16, 0x1E,
    0xB8, 0xA9, 0xB4, 0x99, 0x2C, 0x54, 0x7C, 0xB0, 0x8A, 0xA8, 0x96, 0x36, 0x56, 0x76, 0xF1, 0xB9,
    0xAF, 0xB4, 0xB0, 0x83, 0xC0, 0xB8, 0xA8, 0x97, 0x11, 0xB1, 0x8F, 0x98, 0xB9, 0xAF, 0xF0, 0x24,
    0x08, 0x44, 0x10, 0x64, 0x18, 0xF1, 0xA3, 0x29, 0x55, 0x7D, 0xAF, 0x83, 0xB5, 0x93, 0xAF, 0xF0,
    0x00, 0x28, 0x50, 0xF1, 0xA3, 0x86, 0x9F, 0x61, 0xA6, 0xDA, 0xDE, 0xDF, 0xD9, 0xFA, 0xA3, 0x86,
    0x96, 0xDB, 0x31, 0xA6, 0xD9, 0xF8, 0xDF, 0xBA, 0xA6, 0x8F, 0xC2, 0xC5, 0xC7, 0xB2, 0x8C, 0xC1,
    0xB8, 0xA2, 0xDF, 0xDF, 0xDF, 0xA3, 0xDF, 0xDF, 0xDF, 0xD8, 0xD8, 0xF1, 0xB8, 0xA8, 0xB2, 0x86,

    // bank 4, 256 bytes
    0xB4, 0x98, 0x0D, 0x35, 0x5D, 0xB8, 0xAA, 0x98, 0xB0, 0x87, 0x2D, 0x35, 0x3D, 0xB2, 0xB6, 0xBA,
    0xAF, 0x8C, 0x96, 0x19, 0x8F, 0x9F, 0xA7, 0x0E, 0x16, 0x1E, 0xB4, 0x9A, 0xB8, 0xAA, 0x87, 0x2C,
    0x54, 0x7C, 0xB9, 0xA3, 0xDE, 0xDF, 0xDF, 0xA3, 0xB1, 0x80, 0xF2, 0xC4, 0xCD, 0xC9, 0xF1, 0xB8,
    0xA9, 0xB4, 0x99, 0x83, 0x0D, 0x35, 0x5D, 0x89, 0xB9, 0xA3, 0x2D, 0x55, 0x7D, 0xB5, 0x93, 0xA3,
    0x0E, 0x16, 0x1E, 0xA9, 0x2C, 0x54, 0x7C, 0xB8, 0xB4, 0xB0, 0xF1, 0x97, 0x83, 0xA8, 0x11, 0x84,
    0xA5, 0x09, 0x98, 0xA3, 0x83, 0xF0, 0xDA, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xD8, 0xF1, 0xA5,
    0x29, 0x55, 0x7D, 0xA5, 0x85, 0x95, 0x02, 0x1A, 0x2E, 0x3A, 0x56, 0x5A, 0x40, 0x48, 0xF9, 0xF3,
    0xA3, 0xD9, 0xF8, 0xF0, 0x98, 0x83, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0x97, 0x82, 0xA8, 0xF1,
    0x11, 0xF0, 0x98, 0xA2, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xDA, 0xF3, 0xDE, 0xD8, 0x83, 0xA5,
    0x94, 0x01, 0xD9, 0xA3, 0x02, 0xF1, 0xA2, 0xC3, 0xC5, 0xC7, 0xD8, 0xF1, 0x84, 0x92, 0xA2, 0x4D,
    0xDA, 0x2A, 0xD8, 0x48, 0x69, 0xD9, 0x2A, 0xD8, 0x68, 0x55, 0xDA, 0x32, 0xD8, 0x50, 0x71, 0xD9,
    0x32, 0xD8, 0x70, 0x5D, 0xDA, 0x3A, 0xD8, 0x58, 0x79, 0xD9, 0x3A, 0xD8, 0x78, 0x93, 0xA3, 0x4D,
    0xDA, 0x2A, 0xD8, 0x48, 0x69, 0xD9, 0x2A, 0xD8, 0x68, 0x55, 0xDA, 0x32, 0xD8, 0x50, 0x71, 0xD9,
    0x32, 0xD8, 0x70, 0x5D, 0xDA, 0x3A, 0xD8, 0x58, 0x79, 0xD9, 0x3A, 0xD8, 0x78, 0xA8, 0x8A, 0x9A,
    0xF0, 0x28, 0x50, 0x78, 0x9E, 0xF3, 0x88, 0x18, 0xF1, 0x9F, 0x1D, 0x98, 0xA8, 0xD9, 0x08, 0xD8,
    0xC8, 0x9F, 0x12, 0x9E, 0xF3, 0x15, 0xA8, 0xDA, 0x12, 0x10, 0xD8, 0xF1, 0xAF, 0xC8, 0x97, 0x87,

    // bank 5, 256 bytes
    0x34, 0xB5, 0xB9, 0x94, 0xA4, 0x21, 0xF3, 0xD9, 0x22, 0xD8, 0xF2, 0x2D, 0xF3, 0xD9, 0x2A, 0xD8,
    0xF2, 0x35, 0xF3, 0xD9, 0x32, 0xD8, 0x81, 0xA4, 0x60, 0x60, 0x61, 0xD9, 0x61, 0xD8, 0x6C, 0x68,
    0x69, 0xD9, 0x69, 0xD8, 0x74, 0x70, 0x71, 0xD9, 0x71, 0xD8, 0xB1, 0xA3, 0x84, 0x19, 0x3D, 0x5D,
    0xA3, 0x83, 0x1A, 0x3E, 0x5E, 0x93, 0x10, 0x30, 0x81, 0x10, 0x11, 0xB8, 0xB0, 0xAF, 0x8F, 0x94,
    0xF2, 0xDA, 0x3E, 0xD8, 0xB4, 0x9A, 0xA8, 0x87, 0x29, 0xDA, 0xF8, 0xD8, 0x87, 0x9A, 0x35, 0xDA,
    0xF8, 0xD8, 0x87, 0x9A, 0x3D, 0xDA, 0xF8, 0xD8, 0xB1, 0xB9, 0xA4, 0x98, 0x85, 0x02, 0x2E, 0x56,
    0xA5, 0x81, 0x00, 0x0C, 0x14, 0xA3, 0x97, 0xB0, 0x8A, 0xF1, 0x2D, 0xD9, 0x28, 0xD8, 0x4D, 0xD9,
    0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0xB1, 0x84, 0x0D, 0xDA, 0x0E, 0xD8, 0xA3, 0x29, 0x83, 0xDA,
    0x2C, 0x0E, 0xD8, 0xA3, 0x84, 0x49, 0x83, 0xDA, 0x2C, 0x4C, 0x0E, 0xD8, 0xB8, 0xB0, 0xA8, 0x8A,
    0x9A, 0xF5, 0x20, 0xAA, 0xDA, 0xDF, 0xD8, 0xA8, 0x40, 0xAA, 0xD0, 0xDA, 0xDE, 0xD8, 0xA8, 0x60,
    0xAA, 0xDA, 0xD0, 0xDF, 0xD8, 0xF1, 0x97, 0x86, 0xA8, 0x31, 0x9B, 0x06, 0x99, 0x07, 0xAB, 0x97,
    0x28, 0x88, 0x9B, 0xF0, 0x0C, 0x20, 0x14, 0x40, 0xB8, 0xB0, 0xB4, 0xA8, 0x8C, 0x9C, 0xF0, 0x04,
    0x28, 0x51, 0x79, 0x1D, 0x30, 0x14, 0x38, 0xB2, 0x82, 0xAB, 0xD0, 0x98, 0x2C, 0x50, 0x50, 0x78,
    0x78, 0x9B, 0xF1, 0x1A, 0xB0, 0xF0, 0x8A, 0x9C, 0xA8, 0x29, 0x51, 0x79, 0x8B, 0x29, 0x51, 0x79,
    0x8A, 0x24, 0x70, 0x59, 0x8B, 0x20, 0x58, 0x71, 0x8A, 0x44, 0x69, 0x38, 0x8B, 0x39, 0x40, 0x68,
    0x8A, 0x64, 0x48, 0x31, 0x8B, 0x30, 0x49, 0x60, 0xA5, 0x88, 0x20, 0x09, 0x71, 0x58, 0x44, 0x68,

    // bank 6, 256 bytes
    0x11, 0x39, 0x64, 0x49, 0x30, 0x19, 0xF1, 0xAC, 0x00, 0x2C, 0x54, 0x7C, 0xF0, 0x8C, 0xA8, 0x04,
    0x28, 0x50, 0x78, 0xF1, 0x88, 0x97, 0x26, 0xA8, 0x59, 0x98, 0xAC, 0x8C, 0x02, 0x26, 0x46, 0x66,
    0xF0, 0x89, 0x9C, 0xA8, 0x29, 0x51, 0x79, 0x24, 0x70, 0x59, 0x44, 0x69, 0x38, 0x64, 0x48, 0x31,
    0xA9, 0x88, 0x09, 0x20, 0x59, 0x70, 0xAB, 0x11, 0x38, 0x40, 0x69, 0xA8, 0x19, 0x31, 0x48, 0x60,
    0x8C, 0xA8, 0x3C, 0x41, 0x5C, 0x20, 0x7C, 0x00, 0xF1, 0x87, 0x98, 0x19, 0x86, 0xA8, 0x6E, 0x76,
    0x7E, 0xA9, 0x99, 0x88, 0x2D, 0x55, 0x7D, 0x9E, 0xB9, 0xA3, 0x8A, 0x22, 0x8A, 0x6E, 0x8A, 0x56,
    0x8A, 0x5E, 0x9F, 0xB1, 0x83, 0x06, 0x26, 0x46, 0x66, 0x0E, 0x2E, 0x4E, 0x6E, 0x9D, 0xB8, 0xAD,
    0x00, 0x2C, 0x54, 0x7C, 0xF2, 0xB1, 0x8C, 0xB4, 0x99, 0xB9, 0xA3, 0x2D, 0x55, 0x7D, 0x81, 0x91,
    0xAC, 0x38, 0xAD, 0x3A, 0xB5, 0x83, 0x91, 0xAC, 0x2D, 0xD9, 0x28, 0xD8, 0x4D, 0xD9, 0x48, 0xD8,
    0x6D, 0xD9, 0x68, 0xD8, 0x8C, 0x9D, 0xAE, 0x29, 0xD9, 0x04, 0xAE, 0xD8, 0x51, 0xD9, 0x04, 0xAE,
    0xD8, 0x79, 0xD9, 0x04, 0xD8, 0x81, 0xF3, 0x9D, 0xAD, 0x00, 0x8D, 0xAE, 0x19, 0x81, 0xAD, 0xD9,
    0x01, 0xD8, 0xF2, 0xAE, 0xDA, 0x26, 0xD8, 0x8E, 0x91, 0x29, 0x83, 0xA7, 0xD9, 0xAD, 0xAD, 0xAD,
    0xAD, 0xF3, 0x2A, 0xD8, 0xD8, 0xF1, 0xB0, 0xAC, 0x89, 0x91, 0x3E, 0x5E, 0x76, 0xF3, 0xAC, 0x2E,
    0x2E, 0xF1, 0xB1, 0x8C, 0x5A, 0x9C, 0xAC, 0x2C, 0x28, 0x28, 0x28, 0x9C, 0xAC, 0x30, 0x18, 0xA8,
    0x98, 0x81, 0x28, 0x34, 0x3C, 0x97, 0x24, 0xA7, 0x28, 0x34, 0x3C, 0x9C, 0x24, 0xF2, 0xB0, 0x89,
    0xAC, 0x91, 0x2C, 0x4C, 0x6C, 0x8A, 0x9B, 0x2D, 0xD9, 0xD8, 0xD8, 0x51, 0xD9, 0xD8, 0xD8, 0x79,

    // bank 7, 138 bytes (remainder)
    0xD9, 0xD8, 0xD8, 0xF1, 0x9E, 0x88, 0xA3, 0x31, 0xDA, 0xD8, 0xD8, 0x91, 0x2D, 0xD9, 0x28, 0xD8,
    0x4D, 0xD9, 0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0xB1, 0x83, 0x93, 0x35, 0x3D, 0x80, 0x25, 0xDA,
    0xD8, 0xD8, 0x85, 0x69, 0xDA, 0xD8, 0xD8, 0xB4, 0x93, 0x81, 0xA3, 0x28, 0x34, 0x3C, 0xF3, 0xAB,
    0x8B, 0xF8, 0xA3, 0x91, 0xB6, 0x09, 0xB4, 0xD9, 0xAB, 0xDE, 0xFA, 0xB0, 0x87, 0x9C, 0xB9, 0xA3,
    0xDD, 0xF1, 0xA3, 0xA3, 0xA3, 0xA3, 0x95, 0xF1, 0xA3, 0xA3, 0xA3, 0x9D, 0xF1, 0xA3, 0xA3, 0xA3,
    0xA3, 0xF2, 0xA3, 0xB4, 0x90, 0x80, 0xF2, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3,
    0xA3, 0xB2, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xB0, 0x87, 0xB5, 0x99, 0xF1, 0xA3, 0xA3, 0xA3,
    0x98, 0xF1, 0xA3, 0xA3, 0xA3, 0xA3, 0x97, 0xA3, 0xA3, 0xA3, 0xA3, 0xF3, 0x9B, 0xA3, 0xA3, 0xDC,
    0xB9, 0xA7, 0xF1, 0x26, 0x26, 0x26, 0xD8, 0xD8, 0xFF
};


static const unsigned char dmpConfig[MPU6050_DMP_CONFIG_SIZE] = {
//  BANK    OFFSET  LENGTH  [DATA]
    0x03,   0x7B,   0x03,   0x4C, 0xCD, 0x6C,         // FCFG_1 inv_set_gyro_calibration
    0x03,   0xAB,   0x03,   0x36, 0x56, 0x76,         // FCFG_3 inv_set_gyro_calibration
    0x00,   0x68,   0x04,   0x02, 0xCB, 0x47, 0xA2,   // D_0_104 inv_set_gyro_calibration
    0x02,   0x18,   0x04,   0x00, 0x05, 0x8B, 0xC1,   // D_0_24 inv_set_gyro_calibration
    0x01,   0x0C,   0x04,   0x00, 0x00, 0x00, 0x00,   // D_1_152 inv_set_accel_calibration
    0x03,   0x7F,   0x06,   0x0C, 0xC9, 0x2C, 0x97, 0x97, 0x97, // FCFG_2 inv_set_accel_calibration
    0x03,   0x89,   0x03,   0x26, 0x46, 0x66,         // FCFG_7 inv_set_accel_calibration
    0x00,   0x6C,   0x02,   0x20, 0x00,               // D_0_108 inv_set_accel_calibration
    0x02,   0x40,   0x04,   0x00, 0x00, 0x00, 0x00,   // CPASS_MTX_00 inv_set_compass_calibration
    0x02,   0x44,   0x04,   0x00, 0x00, 0x00, 0x00,   // CPASS_MTX_01
    0x02,   0x48,   0x04,   0x00, 0x00, 0x00, 0x00,   // CPASS_MTX_02
    0x02,   0x4C,   0x04,   0x00, 0x00, 0x00, 0x00,   // CPASS_MTX_10
    0x02,   0x50,   0x04,   0x00, 0x00, 0x00, 0x00,   // CPASS_MTX_11
    0x02,   0x54,   0x04,   0x00, 0x00, 0x00, 0x00,   // CPASS_MTX_12
    0x02,   0x58,   0x04,   0x00, 0x00, 0x00, 0x00,   // CPASS_MTX_20
    0x02,   0x5C,   0x04,   0x00, 0x00, 0x00, 0x00,   // CPASS_MTX_21
    0x02,   0xBC,   0x04,   0x00, 0x00, 0x00, 0x00,   // CPASS_MTX_22
    0x01,   0xEC,   0x04,   0x00, 0x00, 0x40, 0x00,   // D_1_236 inv_apply_endian_accel
    0x03,   0x7F,   0x06,   0x0C, 0xC9, 0x2C, 0x97, 0x97, 0x97, // FCFG_2 inv_set_mpu_sensors
    0x04,   0x02,   0x03,   0x0D, 0x35, 0x5D,         // CFG_MOTION_BIAS inv_turn_on_bias_from_no_motion
    0x04,   0x09,   0x04,   0x87, 0x2D, 0x35, 0x3D,   // FCFG_5 inv_set_bias_update
    0x00,   0xA3,   0x01,   0x00,                     // D_0_163 inv_set_dead_zone
                 // SPECIAL 0x01 = enable interrupts
    0x00,   0x00,   0x00,   0x01, // SET INT_ENABLE at i=22, SPECIAL INSTRUCTION
    0x07,   0x86,   0x01,   0xFE,                     // CFG_6 inv_set_fifo_interupt
    0x07,   0x41,   0x05,   0xF1, 0x20, 0x28, 0x30, 0x38, // CFG_8 inv_send_quaternion
    0x07,   0x7E,   0x01,   0x30,                     // CFG_16 inv_set_footer
    0x07,   0x46,   0x01,   0x9A,                     // CFG_GYRO_SOURCE inv_send_gyro
    0x07,   0x47,   0x04,   0xF1, 0x28, 0x30, 0x38,   // CFG_9 inv_send_gyro -> inv_construct3_fifo
    0x07,   0x6C,   0x04,   0xF1, 0x28, 0x30, 0x38,   // CFG_12 inv_send_accel -> inv_construct3_fifo
    0x02,   0x16,   0x02,   0x00, 0x01                // D_0_22 inv_set_fifo_rate

    // This very last 0x01 WAS a 0x09, which drops the FIFO rate down to 20 Hz. 0x07 is 25 Hz,
    // 0x01 is 100Hz. Going faster than 100Hz (0x00=200Hz) tends to result in very noisy data.
    // DMP output frequency is calculated easily using this equation: (200Hz / (1 + value))

    // It is important to make sure the host processor can keep up with reading and processing
    // the FIFO output at the desired rate. Handling FIFO overflow cleanly is also a good idea.
};

static const unsigned char dmpUpdates[MPU6050_DMP_UPDATES_SIZE]  = {
    0x01,   0xB2,   0x02,   0xFF, 0xFF,
    0x01,   0x90,   0x04,   0x09, 0x23, 0xA1, 0x35,
    0x01,   0x6A,   0x02,   0x06, 0x00,
    0x01,   0x60,   0x08,   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00,   0x60,   0x04,   0x40, 0x00, 0x00, 0x00,
    0x01,   0x62,   0x02,   0x00, 0x00,
    0x00,   0x60,   0x04,   0x00, 0x40, 0x00, 0x00
};

/* Private Functions declaration ------------------------------------------------------------------*/

static void resetDMP(void);
static void setMemoryBank(uint8_t bank, bool prefetchEnabled, bool userBank);
static void setMemoryStartAddress(uint8_t address);
static void readMemoryBlock(uint8_t *data, uint16_t dataSize, uint8_t bank, uint8_t address);
static bool writeMemoryBlock(const uint8_t *data, uint16_t dataSize, uint8_t bank, uint8_t address, bool verify, bool useProgMem);
static bool writeProgMemoryBlock(const uint8_t *data, uint16_t dataSize, uint8_t bank , uint8_t address , bool verify );
static bool writeDMPConfigurationSet(const uint8_t *data, uint16_t dataSize, bool useProgMem);
static bool writeProgDMPConfigurationSet(const uint8_t *data, uint16_t dataSize);
static void setDMPConfig1(uint8_t config);
static void setDMPConfig2(uint8_t config);
static uint16_t getFIFOCount(void);
static void getFIFOBytes(uint8_t *data, uint8_t length);
static void getQuaternion(MPU6050_DMP* dmpStruct  , const uint8_t* packet);
static void getRealAcceleration(int16_t* real_accel ,  const uint8_t* packet);
static void calculateOrientation(float* q , float * rpy);
static void calculateGravity(float* q , float * gravity);
static void calculateLinearAcceleration(float* q , int16_t* real_accel , float * linear_accel);
static void calculateHeading(float* q , float * heading);



/**
 *  ======================================================================================
 * |				       DMP Utility Function Implementation	     	         		  |
 *  ======================================================================================
 */


/**
 * @brief  DMP_Initialize : Initialize the Digital Motion Processing Unit (DMP)
 * @param   : None
 * @retval uint8_t : 0 if success operation
 * 					 1 if DMP code verification failed.
 * 					 2 if DMP configuration verification failed.
 * @note	if DMP is to be used you have to initialize the operation of MPU6050 sensors first @see MPU6050.h
 */
uint8_t MPU6050_DMP_Initialize(void) {

    // disable sleep mode
    MPU6050_setSleepEnabled(false);

    // load DMP code into memory banks
    if (writeProgMemoryBlock(dmpMemory, MPU6050_DMP_CODE_SIZE , 0 , 0 , true)) {

        // write DMP configuration
        if (writeProgDMPConfigurationSet(dmpConfig, MPU6050_DMP_CONFIG_SIZE)) {


            // Setting clock source to Z Gyro (As recommended in data sheet)
            MPU6050_setClockSource(MPU6050_CLOCK_PLL_ZGYRO);

            // Setting DMP and FIFO_OFLOW interrupts enabled...
            MPU6050_setIntFIFOBufferOverflowEnabled(true);
            MPU6050_DMP_setIntEnable(true);

            // Setting DMP programm start address
            //write start address MSB into register
            setDMPConfig1(0x03);
            //write start address LSB into register
            setDMPConfig2(0x00);

            // Writing final memory update 1/7 (function unknown)...

            uint8_t dmpUpdate[16], j;
            uint16_t pos = 0;
            for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++) dmpUpdate[j] = pgm_read_byte(&dmpUpdates[pos]);
            writeMemoryBlock(dmpUpdate + 3, dmpUpdate[2], dmpUpdate[0], dmpUpdate[1], true, false);

            // Writing final memory update 2/7 (function unknown)...
            for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++) dmpUpdate[j] = pgm_read_byte(&dmpUpdates[pos]);
            writeMemoryBlock(dmpUpdate + 3, dmpUpdate[2], dmpUpdate[0], dmpUpdate[1], true, false);

            // Resetting FIFO...
            MPU6050_resetFIFO();

            // Enabling FIFO...
            MPU6050_setFIFOEnabled(true);

            // Enabling DMP..
            MPU6050_DMP_setEnable(true);

            // Resetting DMP...
            resetDMP();

            // Writing final memory update 3/7 (function unknown)..
            for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++) dmpUpdate[j] = pgm_read_byte(&dmpUpdates[pos]);
            writeMemoryBlock(dmpUpdate + 3, dmpUpdate[2], dmpUpdate[0], dmpUpdate[1], true, false);

            // Writing final memory update 4/7 (function unknown)...
            for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++) dmpUpdate[j] = pgm_read_byte(&dmpUpdates[pos]);
            writeMemoryBlock(dmpUpdate + 3, dmpUpdate[2], dmpUpdate[0], dmpUpdate[1], true, false);

            // Writing final memory update 5/7 (function unknown)...
            for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++) dmpUpdate[j] = pgm_read_byte(&dmpUpdates[pos]);
            writeMemoryBlock(dmpUpdate + 3, dmpUpdate[2], dmpUpdate[0], dmpUpdate[1], true, false);


            // Reading final memory update 6/7 (function unknown)...
            for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++) dmpUpdate[j] = pgm_read_byte(&dmpUpdates[pos]);
            readMemoryBlock(dmpUpdate + 3, dmpUpdate[2], dmpUpdate[0], dmpUpdate[1]);


            // Writing final memory update 7/7 (function unknown)...
            for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++) dmpUpdate[j] = pgm_read_byte(&dmpUpdates[pos]);
            writeMemoryBlock(dmpUpdate + 3, dmpUpdate[2], dmpUpdate[0], dmpUpdate[1], true, false);

            // DMP is good to go! Finally.;

            // Disabling DMP (to be turn on later by user)...
            MPU6050_DMP_setEnable(false);

            // Setting up internal 42-byte (default) DMP packet buffer...
            dmpPacketSize = 42;

            // Resetting FIFO and clearing INT status one last time...
            MPU6050_resetFIFO();
            MPU6050_DMP_getIntStatus();
            MPU6050_getIntFIFOBufferOverflowStatus();

        } else {
           // ERROR! DMP configuration verification failed.
            return 2; // configuration block loading failed
        }
    } else {
        //  ERROR! DMP code verification failed.
        return 1; // main binary block loading failed
    }
    return 0; // success
}
/**
 * @brief  MPU6050_DMP_setEnable : Enable the the DMP unit in the MPU6050.
 * @param  enabale :	true  :  enable DMP.
 * 					 	false :  disable DMP.
 * @retval None :
 * @note		This function should be called after DMP_Initialize()
 */
void MPU6050_DMP_setEnable(bool enabled){

    I2Cdev_writeBit(devAddr, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_DMP_EN_BIT, enabled);
}

/**
 * @brief  MPU6050_DMP_setIntEnable :  Enable or disable the DMP Interrupts.
 * @param  enable :			true  :  enable DMP Interrupt,
 * 					 		false :  disable DMP Interrupt.
 * @retval None :
 * @note
 */
void MPU6050_DMP_setIntEnable(bool enable) {

    I2Cdev_writeBit(devAddr, MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_DMP_INT_BIT, enable);
}


/**
 * @brief  MPU6050_DMP_getIntStatus :  get the current state of the DMP Interrupt.
 * @param  None :
 * @retval bool :			true  :   DMP Interrupt is set.
 * 					 		false :  disable DMP Interrupt is not set.
 * @note
 */
bool MPU6050_DMP_getIntStatus(void){

	uint8_t	data;
    I2Cdev_readBit(devAddr, MPU6050_RA_INT_STATUS, MPU6050_INTERRUPT_DMP_INT_BIT, &data);
    return data;

}
/**
 * @brief  MPU6050_DMP_IsReady : check if there is any packets ready to be processed
 * @param  None :
 * @retval return_type :			true  :   DMP Packet is ready to process.
 * 					 				false :   DMP Packet is not ready to process.
 * @note	you can check this function periodically if the interrupt is disabled
 */
bool MPU6050_DMP_IsReady(void){
    return getFIFOCount() >= dmpPacketSize;
}

/**
 * @brief  MPU6050_DMP_getQuaternions :  updates the quaternion and orientation values of the passing struct
 * @param  dmpStruct   :  A pointer to DMP struct
 * @retval bool		   :  true if the value has updated , false if not
 * @note
 */
bool MPU6050_DMP_getQuaternions(MPU6050_DMP* dmpStruct){



	if (!MPU6050_DMP_IsReady()) return false;

	uint8_t* packetBuffer = (uint8_t*) malloc(dmpPacketSize);

	if (packetBuffer == NULL) return false;

	getFIFOBytes(packetBuffer, dmpPacketSize);

	getQuaternion(dmpStruct, packetBuffer);

	free((void*)packetBuffer);
	return true;

}

/**
 * @brief  MPU6050_DMP_getOrientation :  updates the quaternion and orientation values of the passing struct
 * @param  dmpStruct   :  A pointer to DMP struct
 * @retval bool		   :  true if the value has updated , false if not
 * @note
 */
bool MPU6050_DMP_getOrientation(MPU6050_DMP* dmpStruct){


	if (!MPU6050_DMP_IsReady()) return false;

	uint8_t* packetBuffer = (uint8_t*) malloc(dmpPacketSize);

	if (packetBuffer == NULL) return false;

	getFIFOBytes(packetBuffer, dmpPacketSize);

	getQuaternion(dmpStruct, packetBuffer);

	calculateOrientation(dmpStruct->quaternion, dmpStruct->orientation);

	free((void*)packetBuffer);
	return true;
}

bool MPU6050_DMP_getGravity(MPU6050_DMP* dmpStruct){

	if (!MPU6050_DMP_IsReady()) return false;

	uint8_t* packetBuffer = (uint8_t*) malloc(dmpPacketSize);

	if (packetBuffer == NULL) return false;

	getFIFOBytes(packetBuffer, dmpPacketSize);

	getQuaternion(dmpStruct, packetBuffer);

	calculateGravity(dmpStruct->quaternion, dmpStruct->gravity);

	free((void*)packetBuffer);
	return true;

}

bool MPU6050_DMP_getAcceleration(MPU6050_DMP* dmpStruct){

	if (!MPU6050_DMP_IsReady()) return false;

	uint8_t* packetBuffer = (uint8_t*) malloc(dmpPacketSize);

	if (packetBuffer == NULL) return false;

	getFIFOBytes(packetBuffer, dmpPacketSize);

	getQuaternion(dmpStruct, packetBuffer);

	int16_t vAccel[3];

	getRealAcceleration(vAccel, packetBuffer);
	calculateLinearAcceleration(dmpStruct->quaternion, vAccel, dmpStruct->linear_acceleration);

	free((void*)packetBuffer);
	return true;

}

bool MPU6050_DMP_getAHeading(MPU6050_DMP* dmpStruct){


	if (!MPU6050_DMP_IsReady()) return false;

	uint8_t* packetBuffer = (uint8_t*) malloc(dmpPacketSize);

	if (packetBuffer == NULL) return false;

	getFIFOBytes(packetBuffer, dmpPacketSize);

	getQuaternion(dmpStruct, packetBuffer);

	calculateHeading(dmpStruct->quaternion, &dmpStruct->heading);

	free((void*)packetBuffer);
	return true;

}

bool MPU6050_DMP_getAll(MPU6050_DMP* dmpStruct){

	if (!MPU6050_DMP_IsReady()) return false;

	int16_t vAccel[3];
	uint8_t* packetBuffer = (uint8_t*) malloc(dmpPacketSize);

	if (packetBuffer == NULL) return false;

	getFIFOBytes(packetBuffer, dmpPacketSize);

	getQuaternion(dmpStruct, packetBuffer);
	getRealAcceleration(vAccel, packetBuffer);

	calculateOrientation(dmpStruct->quaternion, dmpStruct->orientation);
	calculateGravity(dmpStruct->quaternion, dmpStruct->gravity);
	calculateLinearAcceleration(dmpStruct->quaternion, vAccel , dmpStruct->linear_acceleration);
	calculateHeading(dmpStruct->quaternion, &dmpStruct->heading);


	free((void*)packetBuffer);
	return true;

}


/**
 *  ======================================================================================
 * |				       DMP Private Function Implementation	     	         		  |
 *  ======================================================================================
 */

static void resetDMP() {

    I2Cdev_writeBit(devAddr, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_DMP_RESET_BIT, true);
}
// MEM_R_W register
// BANK_SEL register
static void setMemoryBank(uint8_t bank, bool prefetchEnabled, bool userBank) {

    bank &= 0x1F;
    if (userBank) bank |= 0x20;
    if (prefetchEnabled) bank |= 0x40;

    I2Cdev_writeByte(devAddr, MPU6050_RA_BANK_SEL, bank);
}


// MEM_START_ADDR register

 static void setMemoryStartAddress(uint8_t address) {

    I2Cdev_writeByte(devAddr, MPU6050_RA_MEM_START_ADDR, address);
}

 static void readMemoryBlock(uint8_t *data, uint16_t dataSize, uint8_t bank, uint8_t address) {

     setMemoryBank(bank, false, false);
     setMemoryStartAddress(address);
     uint8_t chunkSize;

     for (uint16_t i = 0; i < dataSize;) {
         // determine correct chunk size according to bank position and data size
         chunkSize = MPU6050_DMP_MEMORY_CHUNK_SIZE;

         // make sure we don't go past the data size
         if (i + chunkSize > dataSize) chunkSize = dataSize - i;

         // make sure this chunk doesn't go past the bank boundary (256 bytes)
         if (chunkSize > 256 - address) chunkSize = 256 - address;

         // read the chunk of data as specified
         I2Cdev_readBytes(devAddr, MPU6050_RA_MEM_R_W, chunkSize, data + i);

         // increase byte index by [chunkSize]
         i += chunkSize;

         // uint8_t automatically wraps to 0 at 256
         address += chunkSize;

         // if we aren't done, update bank (if necessary) and address
         if (i < dataSize) {
             if (address == 0) bank++;
             setMemoryBank(bank, false, false);
             setMemoryStartAddress(address);
         }
     }
 }

 static bool writeMemoryBlock(const uint8_t *data, uint16_t dataSize, uint8_t bank, uint8_t address, bool verify, bool useProgMem) {

     setMemoryBank(bank, false, false);
     setMemoryStartAddress(address);
     uint8_t chunkSize;
     uint8_t *verifyBuffer=0;
     uint8_t *progBuffer=0;
     uint16_t i;
     uint8_t j;

     if (verify) verifyBuffer = (uint8_t *)malloc(MPU6050_DMP_MEMORY_CHUNK_SIZE);
     if (useProgMem) progBuffer = (uint8_t *)malloc(MPU6050_DMP_MEMORY_CHUNK_SIZE);

     for (i = 0; i < dataSize;) {
         // determine correct chunk size according to bank position and data size
         chunkSize = MPU6050_DMP_MEMORY_CHUNK_SIZE;

         // make sure we don't go past the data size
         if (i + chunkSize > dataSize) chunkSize = dataSize - i;

         // make sure this chunk doesn't go past the bank boundary (256 bytes)
         if (chunkSize > 256 - address) chunkSize = 256 - address;

         if (useProgMem) {
             // write the chunk of data as specified
             for (j = 0; j < chunkSize; j++) progBuffer[j] = pgm_read_byte(data + i + j);
         } else {
             // write the chunk of data as specified
             progBuffer = (uint8_t *)data + i;
         }

         I2Cdev_writeBytes(devAddr, MPU6050_RA_MEM_R_W, chunkSize, progBuffer);

         // verify data if needed
         if (verify && verifyBuffer) {
             setMemoryBank(bank, false, false);
             setMemoryStartAddress(address);
             I2Cdev_readBytes(devAddr, MPU6050_RA_MEM_R_W, chunkSize, verifyBuffer);
             if (memcmp(progBuffer, verifyBuffer, chunkSize) != 0) {

                 free(verifyBuffer);
                 if (useProgMem) free(progBuffer);
                 return false; // uh oh.
             }
         }

         // increase byte index by [chunkSize]
         i += chunkSize;

         // uint8_t automatically wraps to 0 at 256
         address += chunkSize;

         // if we aren't done, update bank (if necessary) and address
         if (i < dataSize) {
             if (address == 0) bank++;
             setMemoryBank(bank, false, false);
             setMemoryStartAddress(address);
         }
     }
     if (verify) free(verifyBuffer);
     if (useProgMem) free(progBuffer);
     return true;
 }

 static bool writeProgMemoryBlock(const uint8_t *data, uint16_t dataSize, uint8_t bank, uint8_t address, bool verify) {
    return writeMemoryBlock(data, dataSize, bank, address, verify, true);
}

 static bool writeDMPConfigurationSet(const uint8_t *data, uint16_t dataSize, bool useProgMem) {

     uint8_t *progBuffer = 0;
 	uint8_t success, special;
     uint16_t i, j;
     if (useProgMem) {
         progBuffer = (uint8_t *)malloc(8); // assume 8-byte blocks, realloc later if necessary
     }

     // config set data is a long string of blocks with the following structure:
     // [bank] [offset] [length] [byte[0], byte[1], ..., byte[length]]
     uint8_t bank, offset, length;
     for (i = 0; i < dataSize;) {
         if (useProgMem) {
             bank = pgm_read_byte(data + i++);
             offset = pgm_read_byte(data + i++);
             length = pgm_read_byte(data + i++);
         } else {
             bank = data[i++];
             offset = data[i++];
             length = data[i++];
         }

         // write data or perform special action
         if (length > 0) {
             // regular block of data to write
             if (useProgMem) {
                 if (sizeof(progBuffer) < length) progBuffer = (uint8_t *)realloc(progBuffer, length);
                 for (j = 0; j < length; j++) progBuffer[j] = pgm_read_byte(data + i + j);
             } else {
                 progBuffer = (uint8_t *)data + i;
             }
             success = writeMemoryBlock(progBuffer, length, bank, offset, true, false);
             i += length;
         } else {
             // special instruction
             // NOTE: this kind of behavior (what and when to do certain things)
             // is totally undocumented. This code is in here based on observed
             // behavior only, and exactly why (or even whether) it has to be here
             // is anybody's guess for now.
             if (useProgMem) {
                 special = pgm_read_byte(data + i++);
             } else {
                 special = data[i++];
             }

             if (special == 0x01) {

                 I2Cdev_writeByte(devAddr, MPU6050_RA_INT_ENABLE, 0x32);  // single operation

                 success = true;
             } else {
                 // unknown special command
                 success = false;
             }
         }

         if (!success) {
             if (useProgMem) free(progBuffer);
             return false; // uh oh
         }
     }
     if (useProgMem) free(progBuffer);
     return true;
 }

 static bool writeProgDMPConfigurationSet(const uint8_t *data, uint16_t dataSize) {

    return writeDMPConfigurationSet(data, dataSize, true);
}

 static void setDMPConfig1(uint8_t config) {

    I2Cdev_writeByte(devAddr, MPU6050_RA_DMP_CFG_1, config);
}

 static void setDMPConfig2(uint8_t config) {
    I2Cdev_writeByte(devAddr, MPU6050_RA_DMP_CFG_2, config);
}

 // FIFO_COUNT* registers

 /** Get current FIFO buffer size.
  * This value indicates the number of bytes stored in the FIFO buffer. This
  * number is in turn the number of bytes that can be read from the FIFO buffer
  * and it is directly proportional to the number of samples available given the
  * set of sensor data bound to be stored in the FIFO (register 35 and 36).
  * @return Current FIFO buffer size
  */
 uint16_t getFIFOCount() {

 	uint8_t buffer[2];
     I2Cdev_readBytes(devAddr, MPU6050_RA_FIFO_COUNTH, 2, buffer);
     return (((uint16_t)buffer[0]) << 8) | buffer[1];
 }
 // FIFO_R_W register

 /** Get byte from FIFO buffer.
  * This register is used to read and write data from the FIFO buffer. Data is
  * written to the FIFO in order of register number (from lowest to highest). If
  * all the FIFO enable flags (see below) are enabled and all External Sensor
  * Data registers (Registers 73 to 96) are associated with a Slave device, the
  * contents of registers 59 through 96 will be written in order at the Sample
  * Rate.
  *
  * The contents of the sensor data registers (Registers 59 to 96) are written
  * into the FIFO buffer when their corresponding FIFO enable flags are set to 1
  * in FIFO_EN (Register 35). An additional flag for the sensor data registers
  * associated with I2C Slave 3 can be found in I2C_MST_CTRL (Register 36).
  *
  * If the FIFO buffer has overflowed, the status bit FIFO_OFLOW_INT is
  * automatically set to 1. This bit is located in INT_STATUS (Register 58).
  * When the FIFO buffer has overflowed, the oldest data will be lost and new
  * data will be written to the FIFO.
  *
  * If the FIFO buffer is empty, reading this register will return the last byte
  * that was previously read from the FIFO until new data is available. The user
  * should check FIFO_COUNT to ensure that the FIFO buffer is not read when
  * empty.
  *
  * @return Byte from FIFO buffer
  */

 static void getFIFOBytes(uint8_t *data, uint8_t length) {
     if(length > 0){
         I2Cdev_readBytes(devAddr, MPU6050_RA_FIFO_R_W, length, data);
     } else {
     	*data = 0;
     }
 }


 static void getQuaternion(MPU6050_DMP* dmpStruct  , const uint8_t* packet){

	 /* ================================================================================================ *
	  | Default MotionApps v2.0 42-byte FIFO packet structure:                                           |
	  |                                                                                                  |
	  | [QUAT W][      ][QUAT X][      ][QUAT Y][      ][QUAT Z][      ][GYRO X][      ][GYRO Y][      ] |
	  |   0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  |
	  |                                                                                                  |
	  | [GYRO Z][      ][ACC X ][      ][ACC Y ][      ][ACC Z ][      ][      ]                         |
	  |  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38  39  40  41                          |
	  * ================================================================================================ */


	 	 int16_t qI[4];
	 	 float lsbFactor;

	    qI[0] = ((packet[0] << 8) | packet[1]);
	    qI[1] = ((packet[4] << 8) | packet[5]);
	    qI[2] = ((packet[8] << 8) | packet[9]);
	    qI[3] = ((packet[12] << 8)| packet[13]);

		switch (dmpStruct->ptrMPU->AccelerometerRange) {
			case MPU6050_Accelerometer_2G:
				lsbFactor =  (float)1.0f / MPU6050_ACCE_SENS_2;
				break;
			case MPU6050_Accelerometer_4G:
				lsbFactor = (float)1.0f / MPU6050_ACCE_SENS_4;
				break;
			case MPU6050_Accelerometer_8G:
				lsbFactor = (float)1.0f / MPU6050_ACCE_SENS_8;
				break;
			case MPU6050_Accelerometer_16G:
				lsbFactor  = (float)1.0f / MPU6050_ACCE_SENS_16;
				break;
			default:
				lsbFactor = 0.0f;
				break;
			}

        dmpStruct->quaternion[0] = (float)qI[0] * lsbFactor;
        dmpStruct->quaternion[1] = (float)qI[1] * lsbFactor;
        dmpStruct->quaternion[2] = (float)qI[2] * lsbFactor;
        dmpStruct->quaternion[3] = (float)qI[3] * lsbFactor;


 }


 static void getRealAcceleration(int16_t* real_accel ,  const uint8_t* packet)
 {

	    real_accel[0] = (packet[28] << 8) | packet[29];
	    real_accel[1] = (packet[32] << 8) | packet[33];
	    real_accel[2] = (packet[36] << 8) | packet[37];

 }
 static void calculateOrientation(float* q , float * rpy){



	  // for roll calculation [rotation about X axis]
	  float sinr_cosp = 2.0f *     (q[0]*q[1] + q[2] * q[3]);
	  float cosr_cosp = 1 - (2.0f *(q[1]*q[1] + q[2] * q[2]));

	  // for pitch calculation [rotation about Y axis]
	  float sinp = sqrtf(1.0f + (2.0f *(q[0] * q[2] - q[1] * q[3]))) ;
	  float cosp = sqrtf(1.0f - (2.0f *(q[0] * q[2] - q[1] * q[3]))) ;

	  // for yaw calculation [rotation about Y axis]
	  float siny_cosp = 2.0f * (q[0] * q[3] + q[1] * q[2] );
	  float cosy_cosp = 1.0f - 2.0f * (q[2] * q[2] + q[3] * q[3]);


	  // roll calculation [rotation about X axis]
	  rpy[0] = atan2(sinr_cosp , cosr_cosp);

	  // pitch calculation [rotation about Y axis]
	  rpy[1] = atan2(sinp , cosp);

	 // yaw calculation [rotation about Y axis]
	  rpy[2] = atan2(siny_cosp , cosy_cosp);

// convert radians angles to degrees
		 rpy[0] *= RAD_TO_DEG;
		 rpy[1] *= RAD_TO_DEG;
		 rpy[2] *= RAD_TO_DEG;

 }

 static void calculateGravity(float* q , float * gravity){

	    gravity[0] = 2.0f * (q[1]*q[3] - q[0]*q[2]);
	    gravity[1] = 2.0f * (q[0]*q[1] + q[2]*q[3]);
	    gravity[2] = q[0]*q[0] - q[01]*q[1] - q[2]*q[2] + q[3]*q[3];
 }

 static void calculateLinearAcceleration(float* q , int16_t* real_accel , float * linear_accel) {

	 // TODO: implement this

}
 static void calculateHeading(float* q , float * heading){
	 // TODO: implement this too
 }
